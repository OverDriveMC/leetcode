求第K大问题最有效的算法即是BFPRT算法,又称为中位数的中位数算法,算法最坏时间复杂度$O(n)$.



通过**修改快速排序中主元的选取方法可以降低快速排序在最坏情况下的时间复杂度(BFPRT算法)**

并且目的只是求出第K,故递归的规模变小,速度也随之提高。

快排思路:

1. 选取主元(首元素,尾元素或一个随机元素)
2. 以选取的主元为分界点,把小于主元的放在左边,大于主元的放在右边
3. 分别对左边和右边进行递归



#### BFPRT算法过程及代码

1. 选取主元

   1.1 将n个元素划分成$\lfloor \frac{n}{5} \rfloor$个组,每组5个元素,若有剩余,舍去。

   1.2 使用插入排序找到$\lfloor \frac{n}{5} \rfloor$个组中每一组的中位数

   1.3 对于(1.2)中找到的**所有中位数**,调用BFPRT算法求出它们**的中位数**,**作为主元** 

2. 以(1.3)选取的主元作为分界点,把小于主元的放在左边,大于主元的放在右边

3. 判断主元位置与k的大小,有选择的对左边或右边递归。



令$T(n)$为所求的时间复杂度,则有:
$$
T(n) \le T(\frac{n}{5}) +T(\frac{7n}{10})  +c\cdot n   \ \ \ (c为一个正常数)
$$
其中:

* $T(\frac{n}{5})$来自getpivotIndex(),n个元素,5个一组,共有$\lfloor \frac{n}{5} \rfloor$个中位数
* $T(\frac{7n}{10})$来自BFPRT(), 在$\lfloor \frac{n}{5} \rfloor$ 个中位数中,主元x大于其中$\frac{1}{2} \cdot \frac{n}{5} =\frac{n}{10}$的中位数，而每个中位数在其本来的5个数的小组中又大于或等于其中的3个数,所以主元x至少大于所有数中的$\frac{n}{10} \cdot 3= \frac{3n}{10}$个，即划分之后,任意一边的长度至少为$\frac{3}{10}$, 在最坏的情况下,每次选择都选到了$\frac{7}{10}$的那一部分
* $c \cdot n$来自其它操作,比如insert_sort(), 以及getpivotIndex()和 partition()里所需的一些额外操作。



设$T(n) =t \cdot n$, 其中 t未知, 可以是一个正常数,也可以是一个关于n的函数,代入上式:
$$
\begin{split}
t \cdot n & \le \frac{t \cdot n}{5} + \frac{7t \cdot n}{10} + c\cdot n \ \ \ (两边消去n)\\
t& \le \frac{t}{5} + \frac{7t}{10} +c \\
t& \le 10c
\end{split}
$$
其中c为一个正常数,故t也是一个正常数,即$T(n) \le 10c \cdot n$, 因此$T(n)=O(n)$



#### 选5而不是2,3,7,9的原因？

首先排除偶数,因为偶数很难选其中位数

对于3而言,会有$T(n) \le T(\frac{n}{3} ) + T(\frac{2n}{3})+c\cdot n$ ,本身还是操作了n个元素,与以5为基准的$\frac{9n}{10}$相比,其复杂并没有减少

对于7,9而言,上式中的10c,整体会增加 



