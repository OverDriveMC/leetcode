/**
定义最初的n个数字(0,1,...,n-1)中最后剩下的数字是关于n和m的方程f(n,m)
这n个数字,第一个被删除的数字是(m-1)%n,记作k,那么删除k之后的剩下的n-1个数字为
0 1 2 ... k-1 k+1...n-1,并且下一个开始计数的数字是k+1,相当于在剩下的序列中,
k+1排到最前面,从而形成序列:
k+1 ... n-1 0 ... k-1
该序列最后剩下的数字也应该是关于n和m的函数,由于这个序列的规律和前面最初的序列不一样(最初的序列从0开始连续序列)
因此该函数不同于前面函数,即为f'(n-1,m),最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f'(n-1,m),所以f(n,m)=f'(n-1,m)
接下来将剩下的n-1个数字的序列k+1 ... n-1 0 ...k-1做一个映射,映射结果为形成一个0到n-2的序列:
k+1  ====> 0
k+2  ====> 1
...  ====> ...
n-1  ====> n-k-2
0    ====> n-k-1
...
k-1  ====> n-2
映射定义为p, 如果映射前的数字是x,那么映射后的数字是(x-k-1)%n-1
逆映射为p^(-1),如果映射后的数字是x,那么映射前的数字是(x+k+1)%n
因为映射之后的序列和最初的序列有同样的形式,都是从0开始的连续序列,因此仍然可以用函数f来表示,记为f(n-1,m)
根据映射规则,映射之前的序列最后剩下的数字f'(n-1,m)=p^(-1)[f(n-1,m) ]= (f(n-1,m)+k+1 ) %n 
把k=(m-1)%n代入得:f(n,m)=f'(n-1,m) =(f(n-1,m)+m )%n
所以找到递推公式,要得到n个数字的序列的最后剩下的数字,只需要得到n-1个数字的序列的最后剩下的数字,以此类推
当n=1时,也就是序列中开始只有一个数字0,那么显然最后剩下的数字就是0,所以这种关系为:
f(n,m)=
	0					n==1
	(f(n-1,m)+m)%n	n>1
得到时间复杂度O(n),空间复杂度O(1)的方法
*/
class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n<=0 || m<=0){
            return -1;
        }
        int res=0;
        for(int i=2;i<=n;i++){
			//注意,每次的n是i
            res=(res+m)%i;
        }
        return res;
    }
};