/**
整数中1出现的次数(从1到n整数中1出现的次数)
每10个数,有一个个位是1,每100个数,有10个十位是1,每1000个数有100个百位是1,做一个循环,
每次计算单个位上1的总个数(个位,十位,百位)
以算百位上1为例子:假设百位上是0,1,和>=2 (可以通过(a+8)/10 来判断是否大于等于2)  三种情况
case 1: n=3141092, a=3141, b=92
	计算百位上1的个数应该为3141 * 100 次
	固定百位为1         ----1**  (前面的数可以从0-3140 一共3141个数,每次后面都可以填0-99 100个数)
case 2: n=3141192, a=3141, b=92
	计算百位上1的个数应该为3141*100 +(92+1)次
	固定百位为1         ----1**  (当前面的数为0-3140的时候,后面的数可以填0-99,一共3141*100个数,
	当前面的数为3141的时候, 后面的数只能填0-92一共93个数)
case 3: n=3141592, a=31415, b=92
	计算百位上1的个数应该为(3141+1)*100次
	固定百位为1,        ----1**   (前面的数可以填0-3141,后面的数可以填0-99,一共3142*100个1)

使用公式可以概括为:
	(a+8)/10 * m + (a%10==1) *(b+1)
*/

#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int ones=0;
        for(long long m=1;m<=n;m*=10){
            int a=n/m;
            int b=n%m;
            int curone=(a+8)/10 * m + (a%10 ==1) *(b+1);
            ones+=curone;
        }
        return ones;
    }
};


int main(){
    Solution s;
    cout<<s.NumberOf1Between1AndN_Solution(3141092)<<endl;
    return 0;
}
